# 25. Иерархия уровней безопасности по оранжевой книге. Понятия идентификации и аутентификации

`def` **Безопасная компьютерная система** - посредством специальных механизмов защиты контроллируется доступ к информации, таким образом, что только имеющие соотсетствующие полномочия лица или процессы, выполняющиеся от их имени, могут получить доступ на чтение, изменение создание или удаление информации.

> Существует 4 основных уровня, но некоторые имеют свои подуровни

## Уровень D

> Когда истема не попадает ни в один из описанных классов

## Уровень C

> Самый слабый из классов безопасности

1. Подсистема идентификации и аутентификации

    - Идентификация - **присвоение** некоторых идентификаторов субъекту

        - То что субъект знает (кодовое слово)
        - То, что субъекту принадлежит (карта, токен)
        - То, что является его неотъемлемой характеристикой (биометрия)

    - Аутентификация - **сопоставление** предъявляемого идентификатора и того, который хранится в системе

    - Авторизация - **назначение** тех или иных прав доступа субъекту, прошедшему аутентификацию

2. Подсистема учёта событий, связанных с безопасностью

3. Изберательный (дискреционный) контроль доступа - в том или ином виде существует матрица вида: субъекты <-> объекты
  
    ![Дискреционный контроль](../Images/%D0%B4%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C.jpg)

## Уровень C1

1. Разделение пользователей и данных
2. Выделение контура обеспечения безопасности

    `def` **Доверенная вычислительная база** - совокупность защитных механизмов, включающих аппаратное и программное обеспечение, отвечающих за приведение в жизнь политики безопасности.

    > По факту это анличие отдельного прилоэения/процесса, которое будет заниматься исколючиткльно решением задач, связанных с безопасностью

3. Сдерства проверки корректности функционирования аппаратных и программных компонентов вычислительной базы (тест, что машина и программа аутентификации вообще работают)

## Уровень C2

1. Журнал контроля доступа к системе

    Журналируются действия пользователя

2. Изоляция ресурсов

    При выделении объекта из некого пула ресурсов доверенной вычислительной базы затем удаляются следы его использования

3. Проводится тестирование на отсутствие видимых недостатков в вышеуказанных в механизмах

## Уровень B

Выяснилось, что получившему доступ субъекту можно нарушить конфиденциальность доступных ему данных, поэтому понадобилось добавить новый способ контроля доступа.

> Разглашение информации

1. Мандатный доступ - каждому объекту ставится в соответствие метка секретности и какждому объекту тоже ставится такая метка

    - **Читать** данные можно своего **уровня и ниже**.
    - **Запись** данных на **свой уровень и выше**.

## Уровень B1

Мандатное управление доступом к выбранным субъектам и объектам _(не все объекты наделены уровнем доступа)_

## Уровень B2

Абсолютно любой субъект и объект должны быть классифицированы и включены в систему управления мандатным доступом

## Уровень B3

Поддержка B2, а также включение домена безопасности

**Домен безопасности** - наличие специального администратора безопасности и системы мониторинга безопасности _(только администратор имеет управление над присвоением классификаций)_

## Уровень A

Поддержка B3, а также формализованные проценуды проектирования, управления и распространения

Проверяем перед построением системы, что её безопасность действительно нельзя нарушить

<br>

# 26. Избирательный (дискреционный) контроль доступа. Ролевой контроль доступа

**Изберательный (дискреционный) контроль доступа** - в том или ином виде существует матрица вида: субъекты <-> объекты

## Методы присвоения дискреционного доступа

1. **Суперпользователь**

    Система имеет **суперпользователя**, и только он имеет право устанавливать любые другие права

    - удобно контролировать выдачу прав
    - вся ответственность ложится на 1-го человека
    - объём выполняемых операций может быть слишком большим для того, чтобы ими управлял один суперпользователь

2. **Владельцы**

    Каждый объект системы имеет привязанного к нему субъекта, называемого **владельцем**, который может назначать права доступа

    - обычно владелец - создатель объекта
    - обычно всё равно есть суперпользователь

3. **Делегирование своего доступа**

    Субъект с определённым правом доступа может передать это право другому субъекту

    - либо делается дополнительный доступ на делегирование. Используется, чтобы тот, кто получил доступ, не получил доступ на само делегирование, тем самым прерывается "цепочка делегирования"

> Access Control List (ACL) - это лист, в котором хранятся субъекты, имеющие доступ к данному объекту _(или перечень объектой, к которым имеет доступ данный субъект)_ (хранится для каждой таблицы/столбца)

## Ролевая модель доступа

Дискреционная матрица строится относительно роль <-> объект _(вместо субъект <-> объект)_, а каждый субъект в свою очередь характеризуется совокупностью ролей

<br>

# 27. Мандатный контроль доступа

Мандатный доступ - каждому объекту ставится в соответствие метка секретности и какждому объекту тоже ставится такая метка

Особенности мандатного контроля доступа:

1. Каждый субъект может читать данные со своим уровнем и ниже
2. Каждый субъект может записывать данные в свой уровень и выше

<br>

# 28. Аудит и шифрование данных в БД

## Аудит

**Аудит** — протоколирование действий с ИС

## Типовые объекты аудита

1. Аутентификация, в том числе неуспешная
2. Завершение сеанса
3. Обращение к объектам
4. Смена привелегий или иных аттрибутов безопасности

## Возможные стратегии

1. Выборочное протоколирование
2. Адаптивное протоколирование

Здаём некоторые сценарии, в ответ на которые есть возможность переводить систему в разные режимы журналирования

## Шифрование

1. Прозрачное шифрование (Transparent Database Decription)

    При записи на диск, файлы шифруем, при прочтении дешифруем

2. Шифрование на уровне столбцов (Raw Level Enctiprion)

    Нельзя получить доступ к тем аттрибутам, к которым у субъекта нет ключа шифрования

3. Шифрование средствами ФС (File System Encription)

    При записи ФС шифрует данные

4. Хеширование (Application Leven Encription)

    Данные всегда зашифрованы, а шифруются они на стороне приложения

## Резюме

В попытках достичь надёжности-безопасности мы упираемся в производительность и упираемся в полоток.

Поэтому появился тренд на распределённость БД

<br>

# 29. Распределенные БД. Определение. Стратегии размещения данных в системе, их достоинства и недостатки. Понятие прозрачности

## Распределённые ДБ

`def` **Распределённая БД** - это набор логически связанных между собой разделяемых данных и их описаний, которые физически распределены по нескоьким вычислительным узлам.

> Понятно, что нужно разделять таблицы

`def` **Фрагментирование** - это разделение отношения, а получившиеся компоненты называются фрагментами.

## Типы распределённых БД

1. Гомогенные - одинаковая СУБД на всех узлах
2. Гетерогенные - разные СУБД на узлах

## Преимущества распределённых БД

1. Может нативно отображать структуру организации
2. Отказоустойчивость?
3. Повышение доступности и надёжности
4. Модульность системы

## Недостатки распределённых БД

1. Повышение сложности
2. Увеличение стоимости владения
3. Проблема защиты
4. Усложнение контроля за целостностью данных
5. Отсутствие стандартов

## Фрагментироваие

1. Горизонтальное (шардирование) - выделение подмножеств строк

2. Вертикальное - пытаемся хранить таблицу не как кортежи со всеми атрибутаит, а отдельно столбцы (храним на разнызх узлах данные разной секретности)

3. Смешанное - очев (когда есть фрагмент таблицы, который часто используется)

`def` **Репликация** - поддержка синхронизированных физических копий некоторго объекта БД

## Стратегии размещения данных в распределённой системе

## 1. Фрагментированное (раздельное) размещение

БД разбиваетсяна непересекующиеся фрагменты, и каждый из фрагментов располагается строго на одном узле

## 2. Размещение с полной репликацией

На каждом узле есть полная реплика всей БД (олимпа ИТМО по рпоге)

## 3. Размещение с выборочной репликацией

Разделяем БД тем или иным способом, и для каждого фрагмента решаем 2 задачи:

1. Сколько копий фрагмента сделать
2. Где их прасположить

> СУБД должна принимать данные решения

## Принципы прозрачности СУБД

## 1. Прозрачность фрагментации

Пользователь не знает ,как фрагментирован тот или иной объект

## 2. Прозрачность расположения фрагмента

Пользователь не знает ,на каком конкретном узле расположен тот фрагмент, к которому он обращается

## 3. Прозрачность количества реплик

Пользователь не может обратиться к конкретнной реплике

## 4. Прозрачность контроля доступа

Пользователь не знает, данных действительно нет или у него нет на них доступа

<br>

# 30. Двенадцать правил Дейта распределенных БД

1. **Локальная автономность**

    Локальные данные принедлежат локальным владельцам и локально сопровождаются (на каждом узле есть свой управленец БД и только он имеет к ним доступ управления)

2. **Отсутствие опоры на центральный узел**

    В системе не должно быть ни одного узла, без которого система не может функционировать

3. **Непрерывное функционирование**

    В системе не должна возникать потребность в плановом останове её функционирования

4. **Независимость от расположения**

    Любой пользователь может получить доступ к данным, хранящимся на любом узле

5. **Независимость от фрагментации**

    Любой пользователь может получить доступ к данным, вне зависимости от их фрагментации

6. **Независимость от репликации**

    Любой пользователь может получить доступ к данным, вне зависимости от наличия реплик

7. **Обработка распределённых запросов**

    Любой пользователь должен иметь возможность обработать любой запрос вне зависимости от количества узлов, на которых расположены запрашиваемые объекты данных

8. **Обработка распределённых транзакций**

    Система должна поддерживать выполнение транзакций с данными, расположенными более чем на одном узле

9. **Независимость от типа оборудования**

    Очев

10. **Независимость от сетевой архитектуры**

    Очев

11. **Независимость от операционной системы**

    Очев

12. **Независимость от типа СУБД**

    Очев

<br>

# 31. Предпосылки к появлению NoSQL баз данных

1. `BigData` - в последнее время началась работа со слишком большим количеством данных

2. Взяимосвязанность данных (косвенные связи) - сопоставив несколько разных баз данных, можно получить новые связи

3. Использование слабо-структурирвоанной информации (очень много конфигураций даже в рамках одной группы)

    - например, фильтры поиска телефона, где какие-то атрибуты могут присутствовать только у одного бренда, в связи с чем хранение такого массива данных в SQL таблице приводит к огромному количеству null значений и неиспользуемых аттрибутов

4. Изменение в архитектурах информационныъ систем - когда граф становится полносвязным, SQL становится очень неэффективным

> Если не получается сделать распределённую систему, давайте тогда **распределим ресурсы**

<br>

# 32. Общие характеристики NoSQL баз данных

1. Отказ от стандарта SQL (он есть, но со множеством отхождений)

2. **Schemaless** (неструктурированность)

    Мы можем менять что-то в структуре данных уже по дороге

3. **Aggregates**

    Впротивовес нормализованным SQL решениям мы пытаемся хранить данные как можно более сгруппированными _(отмена декомпозиции)_

    - Это связано с тем, что зачастую из миллиардов возможных комбинаций SQL запросов (аггрегатов таблиц), зачастую используется 30-50, отсюда и идея о том, чтобы сразу хранить данные в таком виде, в котором их было бы удобно запрашивать

    - Минус заключается в том, что при NoSQL, когда, всё-таки, приходится делать аггрегат данных, приходится фактически просматривать полностью всю базу данных для построения результата запроса

4. **Weak ACID** (Atomicity, Consistenss, Isolation, Durability)

    Транзакция в базе перестаёт сохранять указанные для неё в SQL свойства.

    - На смену ACID пришла другая модель BASE (Basic Avialability, Sost State, Eventual Consistens)

## BASE модель

1. Каждый запрос гарантированно завершается
2. Система может изменять данные даже без ввода или изменения данных извне
3. Конечная непротиворечимость

<br>

# 33. CAP теорема. Пример

`def` **CAP теорема** гласит, что в распределённой информационной системы возможно обеспечить не более двух из перечисленных свойств _(Consistency, Availability, Partition tolerance)_

![CAP-треугольник](../Images/cap-theorem.png)

## Целостность

- Во всех узлах в один момент времени данные не противоречат друг другу

- Два запроса в один момент времени к двум разным узлам, то результат выполнения обоих откликов будет одинаков

> Одинаковые результаты с любого узла в один момент времени

## Доступность

- Любой запрос к распределённой системе завершаеся корректным откликом в пределах заданного интервала времени, однако без гарантии, что отклики от всех узлов совпадут

## Устойчивость к распределению

- Расщепление распределённой системы на несколько изолированных секций не приводит к некоррекности отклика от каждой из секций

> CAP - треугольник

> Все реляционные БД - это `CA-системы`

___

## Пример

## 1. Централизованная система

![Централизованная система](../Images/%D1%86%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0.png)

Является C системой, так как всего один источник правды — + Consistency.

## 2. Решение — нанять компаньона (нет взаимосвязи между обработчиками)

![А-система](../Images/%D0%B0-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0.jpg)

Является A системой, так как при неисправности одного обработчика, может работать другой — +Availability.

Однако теряем Consistency, так как нету связи между источниками правды.

## 3. Принимаем решение о согласовании данных (Распределённая система с транзакционной репликацией данных)

![Транзакционная репликация](../Images/%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F.jpg)

Проблема доступности при недоступности хотя бы одного узла (пользователь ждёт пока я согласую ему запись, пока сам жду ответа от недоступного узла, так как он недоступен по каким-то причинам)

## 4. Распределение системы

  1. Распределённая система с гарантированной репликацией данных

      При звонке клиента пингуем второй узел на доступность. Если получем понг, то согласуем с ним данные, если нет, то кладём изменения в какую-то общую очереь и продолжаем работать.

      Когда узел поднимется, он первым делом из очереди прочитает изменения.

      Это CA система. Но нет Partition tolerance. Так как для соблюдения РТ нужен гарантированный канал связи. Если не пришёл отклик от узла, мы не знаем, это нет связи или узел действительно неактивен. Если положим в очередь, а на самом деле просто не было связи, когда связь восстановится, узел не будет знать о том, что в очереди что-то есть (так как он продолжал работать, просто связи не было). Таким образом получим некорректный отклик при разделении узлов.

  2. Распределённая система с гарантированным откликом

      Целостность данных в конечном счёте.
      AP система.

      После разговора с клиентом сразу рассылаю на все узлы в буфер данные, которые только что получил.

      Все узлы с какой-то переодичностью разбирают свои буферы.
      Тогда на длительном промежутке консистентность будет

  3. Распределённая система с гарантированной целостностью данных

      СР система.
      Невозможно обеспечить полную доступность.

      Блокируем запросы клиентов, если не удаётся подтведрдить статус узла.

<br>

# 34. NoSQL решения: хранилища ключ-значение и документоориентированные БД

## Key-Value DB (Cassandra)

Не храним отношения

**Есть только 3 операции:**

1. Insert (Key-Value)
2. Find (Key)
3. Remove (Key)

Гарантируется только уникальность ключа.
Как правило реализует АР класс.

**Недостатки:**

1. Может нарушиться уникальность ключа
2. Поиск только по ключу

## Document-oriented DB (MongoDB)

В качестве ключа обычно хранится значение, а вот в качестве значения уже хранится какая-то более сложная структура (Json, XML)

<br>

# 35. NoSQL решения: колоночные и графовые БД

## Column-based DB

![Колоночная БД](../Images/column-based-db.jpg)

1. Каждая колонка какого-то отношения хранится фактически как отдельная таблица

2. Хранение нескольких таблиц с дублированием ключевого аттрибута (в пределе переходит к форме ключ-значение)

> Могут быть CA и CP

## Graph DB

![Графовая БД](../Images/grapg-db.jpg)

1. У узлов есть атрибуты, у связей тоже есть атрибуты
2. Граф кластеризуется таким образом, что узлы в одном кластере связаны значительно сильнее, чем узлы из разных кластеров. Кластеры хранятся отдельно.

> Например, в социальной сети граф можно разделить по принципу “кластер=жители конкретной страны” и хранить кластер, например, на серверах в этой стране.

**Плюсы:**

1. Удобно хранить информацию с неизвестной структурой
2. Удобно для хранения социальных сетей, онтологий, баз знаний

**Пролемы:**

1. Сложный поиск по аттрибутам, но лёгкий по связи.

<br>

# 36. База знаний. Определение, отличие от базы данных, замкнутые и открытые БЗ

`def` **База знаний** - это совокупность единиц знаний, которые представляют собой формализованные с помощью некоторого метода представления знаний отражение обхектов предметной области и их взаимосвязей, **действий** над объектами и, возможно, неопределённостей, с которыми эти действия осуществляются.

> База знаний != база данных

## Чем знания отличаются от данных

Считается что знания присущи только человеку _(**животные** - исключение)_.

`def` Данные - это факт, а знания - обработка этих данных.

`def` Данные не врут, а знания врут.

У человека есть воля (иногда), у ИИ - нет.

> В базе знаний есть некоторые "единицы" знаний

`def` **Единица знания** - результат формализации объектов проблемной области и их взаимосвязей.

> Всегда остаётся определённая неопределённость (С) А. В.

## Классификации баз знаний

1. Предполагающие неопределённость

2. Не предполагающие неопределённость

3. Открытые - постоянно получает подпитку новыми фактами (могут появляться противоречия)

4. Замкнутые - интерпретация содержимого в процессе функционирования не изменяется

> С технической точки в основе БЗ лежит БД, но в БД не делаем акцент на продукционность знаний

<br>

# 37. Логическая модель представления знаний

## Логическая модель

База знаний - совокупность из 4-х множеств (`M = <T, P, A, B>`)

`T` - алфавит, словарь
`P` - мн-во формул или синтакцических правил
`A` - аксиомы
`B` - мн-во правил вывода

С помощью этих 4-х множеств можно создать как открытую, так и закрытую базу знаний.

<br>

# 38. Сетевая модель представления знаний, семантическая сеть, онтология

## Сетевая модель

`H = <I, C_1, C_2, ..., C_n, G>`

`I` - информационные единицы

`C_1, ..., C_n` - множество типов связей

- a part of
- is a
- причинно-следственная связь
- временная связь

`G` - граф

> Классифицирующие сети
> Онтология - попытка увязать термины, события, факты и вообще всё
> СППР системы - системы поддержки принятия решения

<br>

# 39. Фреймовая модель представления знаний

## Фреймовая модель

`def` **Фрейм** - структура для описания стереотипной ситуации. Сотоит из некоторых характеристик этой ситуации (слотов) и их значений.

> Слот может содержать не только конкретное значение, но и правило, по которому это значение можно получить.

Данные процедуры могут реагировать на события.

**Виды процедур:**

1. Если добавлено, то
2. Если удалено, то
3. Если нужно, то

> Фреймы обладают возмоджностью наследоваться друг от друга

`def` **Фасет** — слот, принимающий множество значений

<br>

# 40. Продукционная модель представления знаний

## Продукционная модель

Основой продукционной модели является понятие **продукции**

Если <условие>, то <заключение> CF (фактор определённости) <значение>

Формально может быть описана следующим образом: `<I, Q, P, A → B, N>`

`I` — уникальное имя продукции (идентификатор)

`Q` — область применения продукции

`P` — условие срабатывания

`A → B` — ядро продукции

`N` — постусловие применения продукции

> Синтез предыдущих 3-х моделей.
