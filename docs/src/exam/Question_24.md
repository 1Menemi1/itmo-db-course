# 24. Проблемы конкурирующих транзакций и методы их решения. Уровни изоляции транзакций

## Проблемы конкурирующих транзакций

1. **Проблема потерянного обновления**

    Несколько транзакций меняют один и тот же кортеж, в результате сохраится только резльтат внесения изменений последенй транзакции.

    :::tip
    Кладём и списываем деньги со счёта
    :::

2. **Проблема грязного чтения**

    Чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится)

    :::tip
    Кладём и списываем деньги со счёта, после этого пытаемся отменить пополнение
    :::

3. **Проблема неповторяемого чтения**

   Ситуация, когда при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными

4. **Проблема фантомного чтения**

    Ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.

    :::tip
    Сначала считываем данные, потом добавляем новую запись и на основе считанных данных получаем неверный результат (например, среднее значение в параллельных подзапросах)
    :::

## Блокировки

:::tip
Все транзакции строятся на основе блокировок - блокировки кортежей, аттрибутов, таблиц или всей базы данных
:::

### Классификация блокировок

1. Явные (накладывающиеся пользователем)

2. Неявные (накладывающиеся самой СУБД)

3. Монопольные - блокируются все виды доступа к объектам

4. Коллективные - блокируются доступ к чтению? к объектам

Дедлоки

:::tip
Если одна из транзакций пытается наложить блокировку, пересекающиеся с какой-то другой блокировкой - появление **дедлоков**
:::

## Уровни изоляции (для решения конкурирующих транзакций)

1. Незавершённое чтение

    Требует, чтобы изменять данные могла только одна транзакция. Поможет справиться с **проблемой потерянного обновления**.

2. Завершённое чтение

    Если транзакция начала изменение данных, то никакая другая транзакция не сможет их прочитать до завершения первой. Поможет справитсья с **проблемой грязного чтения**.

3. Воспроизводимое чтение

    Если транзакция считывает данные, то никакая другая транзакция не сможет их изменить до завершения первой. _Видимо_, поможет справиться с **проблемой неповторяемого чтения**

4. Сериализуемость

    Если транзакция обращается к данным, то никакая другая транзакция не сможет добавить новые или изменить существующие кортежи в этом объекте данных. _Видимо_, поможет справиться с **проблемой фантомного чтения**

## Долговечность

Обеспечивается журналируемостью транзакций

