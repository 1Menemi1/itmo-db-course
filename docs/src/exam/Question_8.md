# 8. Реляционная и постреляционная модели данных: составы моделей, преимущества и недостатки

## Реляционная модель

Реляционная — relationship (таблица — отношение)

![Реляционная модель](../Images/%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C.png)

## Компоненты реляционной модели

1. **Поле данных** - неделимая, уникально адресуемая единица хранения данных

2. **Отношение** - совокупность множества полей данных

3. **Связь** - хранение с помощью ключа, хранение связи = пара ключей + вес

**Один ко многим** : добавляем ID на продукт (другую сущность)

**Многие ко многим:** отдельная сущность с ID_1, ID_2, другое поле

## Нововведения

1. Связи хранятся в отдельных отношениях _(таблицах)_
2. Фактически от сетевой модели к реляционной мы переходим, реорганизовав хранение связей _(но не только)_

3. Возникают предпосылки для избежания дублирования данных
4. Позволяет гарантировать целостность данных (при грамотной организации)

5. Позволяет гарантировать избежание дублирвоания данных (при грамотной организации)

6. Позволяет гарантировать эффективное времы выполнения операций записи (при грамотной организации)

> **Сама таблица - тоже связь**

**Плюсы:**

1. Более эффективное использование памяти, **относительно** сетевоой и иерархической моделей

2. Более быстрое время выполнения CRUD операций, **относительно** сетевоой и иерархической моделей

**Проблемы:**

1. **Поле** - неделимый элемент данных, поэтому возникает проблема с определением типа данных и их хранением

## Постреляционная модель

> Фактически это реляционная модель, но без целостности данных - поле данных может само по себе являться агрегатом (снимаем требование неделимости с отдельного поля)

Поле данных - _агрегат_

**Плюсы:**

1. Представление данных становится наглядным и нет необходимости соединять таблицы.

**Проблемы:**

1. При нормализации отношенией не гарантируется получение целостных данных, так как мы выносим данные из понятия отношений

2. Целостность данных ложится на плечи разработчиков

3. При большом количестве данных все алгоритмы в основном работают за `O(e)`

> Появилась идея о том, что скорость вычисления намного чажнее, чем память.

<br>

# 9. Многомерная и объектно-ориентированная модели данных: составы моделей, преимущества и недостатки

## Многомерная модель

## Нововведения

Данные организованы не в виде множества связанных двумерных таблиц, а в виде упорядоченных многомерных массивов.

**Срез** — подмножество гиперкуба, полученное путём фиксации одного или нескольких измерений.

1. Позволяет быстро искать данные
2. Ускоряет работу с СУБД (хранит таблицы фактически с кешем)

**Плюсы:**

1. Поиск и извлечение данных производятся гораздо быстрее за счёт того, что многомерная БД денормализована и содержит заранее вычесленные агрегаты.
2. Более простая процедура встраивания функций в многомерную БД
3. Стоимость поддержки ниже, чем у реляционной

**Проблемы:**

1. Неэффективно по памяти
2. Отсутствие значения приведёт к пустой “линии” в “кубе” данных **(olap кубы)**
3. **Olap кубы** очень сложно изменять с точки зрения структуры _(добавляется измерение)_

4. Актуальность кеша

> Сама таблица - связь, все записи - продукты, их объединяет множественное отношение.

## Объектно-ориентированная модель

Иерархическая структура, узлами которой являются объекты.

Между записями устанавливаются связи, подобные связям в ООП. Свойства объектов описываются либо одним из стандартных типов или собственным классом.

## Нововведения

1. Можем хранить объекты целиком, не разбрасывая его на разные таблицы
2. Улучшается производительность в ООП приложениях
3. Удобно с точки хрения распределённых систем

**Плюсы:**

1. Не нужно знать о взаимодействии объектов, просто обращаемся к конкретному.
2. Возможность идентифицировать отдельные записи в базе

**Проблемы:**

1. Зацикливаемся на ООП парадигме
2. Вопрос целостности данных ложится на код
3. Низкая скорость выполнения запрсосов

<br>

# 10. Реляционная модель данных: терминология, свойства отношения

> Основой реляционной базы данных является понятие отношения.

## Терминология

> Отношение - плоская таблица.

**Схема отношения** - первая строка таблицы (заголовок столбцов)

**Кортеж** - это отдельная строка в таблице

**Аттрибут** - это отдельный столбец в таблице

**Поле данных** - пересечение кортежей и аттрибутов

**Домен** - множество допустимых значений аттрибута

**Степень отношения** - количество аттрибутов _(столбцов)_

**Координльность соотношения** - количество кортежей _(строк)_

## Свойства отошения

1. Уникальность имени отношения в реляционной схеме _(каждая таблица имееет уникальное имя)_
2. Каждая ячейка содержит только одно неделимое значение
3. Уникальность имени аттрибута в пределах отношения
4. Значение любого аттрибута берутся из одного и того же домена
5. Каждый кортеж уникален
6. Порядок следования аттрибутов и порядок следования кортежей не имеют значения (депрекейтед из-за производительности)

> В реляционной модели хранятся только отношения _(без связей)_, все объекты однотипны

<br>

# 11. Реляционная модель данных: виды ключей, реализация различных типов связей, виды целостности

## Виды ключей

`def` **Суперключ** - это аттрибут или множество аттрибутов, единственным образом идентифицирующие кортеж.

> _Всё множество аттрибутов само по себе является **суперключом**._

`def` **Потенциальный ключ** - это суперключ, который не содержит модмножество, также являющегося суперключом _(суперключ минимального размера)_.

> _Потенциальный ключ может быть **простым** и **составным**._

`def` **Первичный ключ (Primary Key)** - это один из потенциальных ключей, который выбран для уникальной идентификации кортежей данного отношения.

`def` **Внешний ключ (Foreign Key)** - это аттрибут или множество аттрибутов, которое соответствует потенциальному ключу некоторого, может быть, того же самого отношения.

## Типы связей

## 1. Один-к-одному

Первичный ключ одного из отношений является одновременно и внешним ключём.

> Есть таблица работников, и таблица менеджеров по продажам. Id работника будет `PK`, который взят из `PK` менеджера. Таким образом, Id менеджера - это `PK` и `FK` одновременно.

**Employee**

| Id_Emp (`PK`) | Id_Boss (`FK`) | Other fields |
| :-----------: |:--------------:| :-----------:|
|       2       |        1       |     field    |

**SalesPerson**

| Id_SalesPerson (`PK`, `FK`) | Other fields |
| :-------------------------: | :-----------:|
|           1, 2              |     field    |

## 2. Один-к-многим

> Есть таблица групп и студентов. Значение Id группы у студента будет `FK`, который взят из Id, то есть `PK` группы.

**Student**

| Table_Number | LastName | MiddleName | FirstName | Group_Id (`FK`) |
| :----------: |:--------:| :---------:| :-------: | :-------------: |
|       1      |  Кудашев | Эдуардович |  Искандер |       32011     |

**Group**

| Group_Id (`PK`) |  Other fields |
| :-------------: | :-----------: |
|      32011      |      field    |

## 3. Много-ко-многим

Обычно используются таблицы-связки, хранящие связи по Id.

> Есть менеджеры, каждый из которых продаёт продукты. Создаём таблицу с `PK` продукта и менеджера.

## Виды целостности

1. Сущностная целостность - в отношении ни один аттрибут `PK` не может содержать `NULL` значение
2. Ссылочная целостность - если в отношении существует `FK`, то значение этого ключа должно соответствовать существующему значению `PK` в другом отношении

<br>

# 12. Операции реляционной алгебры: проекция, выборка, объединение, разность, пересечение

## Унарные

## 1. Проекция - `П_{a_1, a_2, a_3, ..., a_n}(R)`

`def` **Проекция** (`SELECT`) - это операция, которая определяет новое отношение, содержащее вертикальном подмножество исходного отношения, создоваемое посредством извлечения значений указанных аттрибутов и исключения из резуьтата строк-дубликатов.

## 2. Выборка - `S_{предикат}(R)`

`def` **Выборка** (`WHERE`) - это операция, которая определяет результирующее отношение, которое содержит только те кортежи из исходного отношения, которые удовлетворяют заданному условию _(предикату)_.

## Бинарные

## 3. Объединение - `R u S`

`def` **Объединение** (`UNION`) - это операция над отношениями R и S, определяющая **новое** отношение, которое включает все кортежи, содержащиеся только в R, все кортежи, содержащиеся только в S и кортежи, содержащиеся одновременно в R и S с исключением дубликатов.

> Объединение возможно только, если отношения совместимы, и обычно объединение считается **опасной операцией**

`def` **Совместимость по объединению** - два отошения R и S будут совместимы по объединению, когда они состоят из одинакового кол-ва аттрибутов, и каждая пара соответствующих аттрибутов будет иметь одинаковый домен.

## 4. Разность - `R - S`

`def` **Разность** - это отношение, состоящее из кортежей, которые есть в отношении R, но отсутствуют в отношении S

> Данная операция требует, чтобы отношения были совместимы по объекдинению

## 5. Пересечение - `R ^ S`

`def` **Пересечение** - это отношение, которое определяет кортежи, присутствующие в обоих отношениях одновременно

<br>

# 13. Операции реляционной алгебры: Тета-соединение, эквисоединение, естественное соединение, левое внешнее соединение, полусоединение

## Небинарные

## 1. Декартово произведение - `R x S`

`def` **Декартово произведение** - определяет новое отношение, которое является результатом конкатенаци каждого кортежа из отношения R с каждым кортежем из отношения S.

## 2. Тета-соединение - `R _f S`, где `f = R * a_i (Theta) S * b_i, (Theta) = { <, <=, =, >, >= }`

`def` **Тета-соединение** (`R _f S`) - определяет новое отношение, которое содержит кортежи из декартова произведения отношений R и S, удовлетворяющие предикату f

___

> Дополнительные операции, не реализованные в `SQL`

## 3. Экви-соединение

`def` **Экви-соединение** - это тета-соединение, где (theta) - это операция равно

## 4. Естественное соединение - `R _ S`

`def` **Естественное соединение** - это соединение по эквивалентности двух отношений, выполненное по всем общим аттрибутам, из результатов которого исключается по одному экземпляру каждого общего аттрибута.

## 5. Левое внешнее соединение - ``

`def` **Левое внешнее соединение** - это тета-соединение, при котором в результирующее отношение включаются также кортежи отношения R, не имеющие совпадающих значений в общих столбцах отношения S.

## 6. Полу-соединение

`def` **Полу-соединение** - определяет отношение, содержащее только те кортежи из R, которые входят в соединение R и S

<br>

# 14. Структура и порядок выполнения предложения Select в SQL

## Как выглядит SELECT

```sql
SELECT [DISTINCT | ALL] { * | [ColumsExpression [AS NewName], ... ] }
FROM TableName [AS NewName]
    [ { INNER | LEFTOUTER | FULL } JOIN ] TasbeName2 [AS NewName]
    ON condition ]
[ WHERE condition ]
[ GROUP BY ColumnList ]
[ HAVING condition ]
[ ORDER BY ColumnList [ ASC | DESC ]]
```

## Последовательность выполнения SELECT

1. `FROM`
2. `JOIN ... ON`
3. `WHERE`
4. `GROUP BY`
5. `HAVING`
6. `SELECT`
7. `DISTINCT`
8. `ORDER BY`

<br>

# 15. Алгоритмы реализации соединений отношений в SQL

Для того, чтобы обеспечить целостность, мы будем заниматься денормализацией _(создавать множество связанных таблиц)_.

Это приводит к снижению **производительности**.

> Соединение таблиц - это дорого!

## 1. Неэффективно (декартово произведение)

> Вложенный цикл

```csharp
for (int i = 0; i < R.Count; ++i)
{
    for (int j = 0; j < S.Count; ++j)
