# 11. Реляционная модель данных: виды ключей, реализация различных типов связей, виды целостности

## Виды ключей

`def` **Суперключ** - это аттрибут или множество аттрибутов, единственным образом идентифицирующие кортеж.

> _Всё множество аттрибутов само по себе является **суперключом**._

`def` **Потенциальный ключ** - это суперключ, который не содержит модмножество, также являющегося суперключом _(суперключ минимального размера)_.

> _Потенциальный ключ может быть **простым** и **составным**._

`def` **Первичный ключ (Primary Key)** - это один из потенциальных ключей, который выбран для уникальной идентификации кортежей данного отношения.

`def` **Внешний ключ (Foreign Key)** - это аттрибут или множество аттрибутов, которое соответствует потенциальному ключу некоторого, может быть, того же самого отношения.

## Типы связей

## 1. Один-к-одному

Первичный ключ одного из отношений является одновременно и внешним ключём.

> Есть таблица работников, и таблица менеджеров по продажам. Id работника будет `PK`, который взят из `PK` менеджера. Таким образом, Id менеджера - это `PK` и `FK` одновременно.

**Employee**

| Id_Emp (`PK`) | Id_Boss (`FK`) | Other fields |
| :-----------: |:--------------:| :-----------:|
|       2       |        1       |     field    |

**SalesPerson**

| Id_SalesPerson (`PK`, `FK`) | Other fields |
| :-------------------------: | :-----------:|
|           1, 2              |     field    |

## 2. Один-к-многим

> Есть таблица групп и студентов. Значение Id группы у студента будет `FK`, который взят из Id, то есть `PK` группы.

**Student**

| Table_Number | LastName | MiddleName | FirstName | Group_Id (`FK`) |
| :----------: |:--------:| :---------:| :-------: | :-------------: |
|       1      |  Кудашев | Эдуардович |  Искандер |       32011     |

**Group**

| Group_Id (`PK`) |  Other fields |
| :-------------: | :-----------: |
|      32011      |      field    |

## 3. Много-ко-многим

Обычно используются таблицы-связки, хранящие связи по Id.

> Есть менеджеры, каждый из которых продаёт продукты. Создаём таблицу с `PK` продукта и менеджера.

## Виды целостности

1. Сущностная целостность - в отношении ни один аттрибут `PK` не может содержать `NULL` значение
2. Ссылочная целостность - если в отношении существует `FK`, то значение этого ключа должно соответствовать существующему значению `PK` в другом отношении

<br>

# 12. Операции реляционной алгебры: проекция, выборка, объединение, разность, пересечение

## Унарные

## 1. Проекция - `П_{a_1, a_2, a_3, ..., a_n}(R)`

`def` **Проекция** (`SELECT`) - это операция, которая определяет новое отношение, содержащее вертикальном подмножество исходного отношения, создоваемое посредством извлечения значений указанных аттрибутов и исключения из резуьтата строк-дубликатов.

## 2. Выборка - `S_{предикат}(R)`

`def` **Выборка** (`WHERE`) - это операция, которая определяет результирующее отношение, которое содержит только те кортежи из исходного отношения, которые удовлетворяют заданному условию _(предикату)_.

## Бинарные

## 3. Объединение - `R u S`

`def` **Объединение** (`UNION`) - это операция над отношениями R и S, определяющая **новое** отношение, которое включает все кортежи, содержащиеся только в R, все кортежи, содержащиеся только в S и кортежи, содержащиеся одновременно в R и S с исключением дубликатов.

> Объединение возможно только, если отношения совместимы, и обычно объединение считается **опасной операцией**

`def` **Совместимость по объединению** - два отошения R и S будут совместимы по объединению, когда они состоят из одинакового кол-ва аттрибутов, и каждая пара соответствующих аттрибутов будет иметь одинаковый домен.

## 4. Разность - `R - S`

`def` **Разность** - это отношение, состоящее из кортежей, которые есть в отношении R, но отсутствуют в отношении S

> Данная операция требует, чтобы отношения были совместимы по объекдинению

## 5. Пересечение - `R ^ S`

`def` **Пересечение** - это отношение, которое определяет кортежи, присутствующие в обоих отношениях одновременно

<br>

# 13. Операции реляционной алгебры: Тета-соединение, эквисоединение, естественное соединение, левое внешнее соединение, полусоединение

## Небинарные

## 1. Декартово произведение - `R x S`

`def` **Декартово произведение** - определяет новое отношение, которое является результатом конкатенаци каждого кортежа из отношения R с каждым кортежем из отношения S.

## 2. Тета-соединение - `R _f S`, где `f = R * a_i (Theta) S * b_i, (Theta) = { <, <=, =, >, >= }`

`def` **Тета-соединение** (`R _f S`) - определяет новое отношение, которое содержит кортежи из декартова произведения отношений R и S, удовлетворяющие предикату f

___

> Дополнительные операции, не реализованные в `SQL`

## 3. Экви-соединение

`def` **Экви-соединение** - это тета-соединение, где (theta) - это операция равно

## 4. Естественное соединение - `R _ S`

`def` **Естественное соединение** - это соединение по эквивалентности двух отношений, выполненное по всем общим аттрибутам, из результатов которого исключается по одному экземпляру каждого общего аттрибута.

## 5. Левое внешнее соединение - ``

`def` **Левое внешнее соединение** - это тета-соединение, при котором в результирующее отношение включаются также кортежи отношения R, не имеющие совпадающих значений в общих столбцах отношения S.

## 6. Полу-соединение

`def` **Полу-соединение** - определяет отношение, содержащее только те кортежи из R, которые входят в соединение R и S

<br>

# 14. Структура и порядок выполнения предложения Select в SQL

## Как выглядит SELECT

```sql
SELECT [DISTINCT | ALL] { * | [ColumsExpression [AS NewName], ... ] }
FROM TableName [AS NewName]
    [ { INNER | LEFTOUTER | FULL } JOIN ] TasbeName2 [AS NewName]
    ON condition ]
[ WHERE condition ]
[ GROUP BY ColumnList ]
[ HAVING condition ]
[ ORDER BY ColumnList [ ASC | DESC ]]
```

## Последовательность выполнения SELECT

1. `FROM`
2. `JOIN ... ON`
3. `WHERE`
4. `GROUP BY`
5. `HAVING`
6. `SELECT`
7. `DISTINCT`
8. `ORDER BY`

<br>

# 15. Алгоритмы реализации соединений отношений в SQL

Для того, чтобы обеспечить целостность, мы будем заниматься денормализацией _(создавать множество связанных таблиц)_.

Это приводит к снижению **производительности**.

> Соединение таблиц - это дорого!

## 1. Неэффективно (декартово произведение)

> Вложенный цикл

```csharp
for (int i = 0; i < R.Count; ++i)
{
    for (int j = 0; j < S.Count; ++j)
    {
        if (R[i].atr != S[j].atr) continue;
        Console.WriteLine(r + s);
    }
}
```

```py
for r in R
    for s in S
        if (r.atr == s.atr)
            print(r + s)
```

## 2. Эффективно

> Предварительная сортировка

```py
R.sort(atr)
S.sort(atr)

while not EndOF(S) ans not EndOF(R)
    if (r.atr < s.atr)
        next(R)
    if (r.atr = s.atr)
        print(r + s)
        next(R)
    if (r.atr > s.atr)
        next(S)
```

<br>

# 16. Нормализация реляционной модели: избыточность, аномалии, суть метода нормальных форм. Виды зависимостей между атрибутами

`def` **Нормализация** - преобразование отношения к виду, отвечающему нормальной форме.

> **Нормальная форма** - некоторая характеристика отношения.

У нормальных форм есь иерархия: каждая следующая является предыдущей.

## Избыточность

**Студент**

|     Фио     | Группа | Образовательная программа |
| :---------: |:------:| :------------------------:|
| Либченко М. | M32011 |      Программирование     |

> Образовательная программа хранится либо у одного студента, либо у всех сразу. В обоих случаях это приводит к своим издержкам.

## Аномалия

## 1. Модификации

`def` **Аномалия модификации** - изменение значения одной записи привлечёт за собой просмотр всей таблицы и изменения некоторых других записей.

## 2. Удаления

`def` **Аномалия удаления** - при удалении записи может пропасть и другая информация.

## 3. Добавления

`def` **Аномалия добавления** - информацию в таблицу нельзя поместить, пока она неполная или требуется дополнительный просмотр табиц.

> Аномалии потенциально приводят нас к нарушению целостности данных.

## Решение проблемы аномалии

**Расширенная таблица студентов**

|  Фио `(PK)` | Группа `(PK)` | Образовательная программа |  Факультет  | Форма обучения |
| :---------: |:-------------:| :-----------------------: |:-----------:| :------------: |
| Либченко М. |     M32011    |      Программирование     |     ФИТиП   |      Очная     |

## Виды зависимостей между атрибутами

## Функциональная зависимость между аттрибутами

`def` **Функциональная зависимость между аттрибутами** `(X -> Y)` - в отношении R атрибут y функцинально зависит от атрибута x тогда и только тогда, когда каждому значению x соответствует в точности одно значение y.

> Факультет функционально зависит от образовательной программы.

## Частичная функциональная зависимость

`def` **Частичная функциональная зависимость** `(ФИО + Группа) -> Образовательная программа` - зависимость неключевого атрибута от часть составного ключа.

## Полная функциональная зависимость

`def` **Полная функциональная зависимость** `(ФИО + Группа) -> Форма обучения` - неключевой атрибут зависит от всего составного ключа.

## Транзитивная функциональная зависимость

`def` **Транзитивная функциональная зависимость** `(X -> Z, Y: X -> Y && Y -> Z)` - существует такое множество атрибутов Y, что выполняется требование о существовании зависимостей `X -> Y && Y -> Z)`

<br>

# 17. Первая и вторая нормальные формы. Примеры

## Первая нормальная форма

`def` Отношение находится в **первой нормальной форме**, если все его атрибуты явзяются простыми.

> ФИО мешает нашей таблице соответствовать первой нормальной форме. Для того, чтобы таблица студента находилась в ПНФ, необходимо разделить столбец ФИО на 3 столбца: Ф, И, О

## Вторая нормальная форма

`def` Отношение находится **во второй нормальной форме**, если оно находится в первой нормальной форме, и каждый неключевой атрибут **функционально полно** зависит от первичного ключа.

|  Ф  |  И  |  О  |  Группа  | Форма обучения |
| :-: | :-: | :-: | :------: | :------------: |
|  Л. |  М. |  В. |  M32011  |      Очная     |

| Группа | Образовательная программа |  Факультет  |
| :----: | :-----------------------: | :---------: |
| M32011 |      Программирование     |    ФИТиП    |

<br>

# 18. Третья нормальная форма. Примеры

## Третья нормальная форма

`def` Отношение находится **в третьей нормальной форме**, если оно находится во второй нормальной форме, и все неключевые атрибуты взаимно независимы и полностью зависят от первичного ключа.

`def` Отношение находится **в третьей нормальной форме**, если оно находится во второй нормальной форме, и ни один ключевой атрибут не находится в транзитивной функциональной зависимости от потенциального ключа.

|  Ф  |  И  |  О  |  Группа  | Форма обучения |
| :-: | :-: | :-: | :------: | :------------: |
|  К. |  И. |  Э. |  M32011  |      Очная     |

| Группа | Образовательная программа |
| :----: | :-----------------------: |
| M32011 |      Программирование     |

| Образовательная программа | Факультет |
| :-----------------------: | :-------: |
|      Программирование     |   ФИТиП   |

<br>

# 19. Нормальная форма Бойса-Кодда. Примеры

## Нормальная форма Бойса-Кодда

**Проекты**

|  Номер студента  |     ФИО    |  Номер проекта  |  Роль  |
| :--------------: | :--------: | :-------------: | :----: |
|       307484     | Кудашев И. |         1       | Бекенд |

> Данное отношение не соответствует НФ Бойса-Кодда

`def` Отношение находится **в нормальной форме Бойса-Кодда**, если детерминанты _(зависимые части)_ всех зависимостей являются потенциальными ключами.

## Приведение к нормальной форме Бойса-Кодда

| Студент | Номер студента |    ФИО    |
| :-----: | :------------: | :-------: |
| Кудашев |      307484    |  К. И. Э. |

|  Номер студента  |  Номер проекта  |  Роль  |
| :--------------: | :-------------: | :----: |
|       307484     |         1       | Бекенд |

<br>

# 20. Четвертая нормальная форма. Примеры

## Четвёртая нормальная форма

`def` Отношение находится **в четвёртой нормальной форме**, если оно находится в нормальной форме Бойса-Кодда, и не содержит многозначных зависимостей.

|  Дисциплина |    Лектор    |    Практик   |
| :---------: | :----------: | :----------: |
| Базы данных | Маятин А. В. | Маятин А. В. |

> Не соответствует четвёртой нормальной форме, но соответствует всем предыдущим

## Приведение к четвёртой нормальной форме**

**Лекторы**

|  Дисциплина |     Лектор   |
| :---------: | :----------: |
| Базы данных | Маятин А. В. |

**Практики**

|  Дисциплина |    Практик    |
| :---------: | :-----------: |
| Базы данных |  Маятин А. В. |

> Вопрос приведения к четвёртой нормальной форме - вопрос **интерпритации** данных.

<br>

# 21. Использование индексов для повышения производительности. Виды индексов

> Индекс - это механизм, который направлен на оптимизацию поиска.

Таблица №1

| Табельный |     ФИО     | Группа |
| :-------: | :---------: | :----: |
|  308372   | Либченко М. | M32011 |

Таблица №2

| Группа |   О. Программа   |
| :----: | :--------------: |
| M32011 | Программирование |

`def` **Индекс** - это метод, который позволяет получить структуру данных, предназначенную для оптимизации поиска.

Как выглядит индекс:

| Ключ | Значение (адрес кортежа в таблице) |
| :--: | :--------------------------------: |
| key  |                value               |

## Варианты индексов

## 1. Первичный индекс

`def` **Первичный индекс** - файл упорядочен по первичному ключу, и по нему же построен индекс, так что гарантируется уникальность каждой записи (кортежа)

| Ключ (Табельный) | Значение (адрес кортежа в таблице) |
| :--------------: | :--------------------------------: |
|      308372      |               value                |

Этот индкс можно переформатировать в какую-нибудь структуру данных, например, **красно-чёрное дерево**

- **Хеш** индекс

| Ключ (хеш табельного) | Значение (адрес кортежа в таблице) |
| :-------------------: | :--------------------------------: |
|       hashValue       |                value               |

> Для избавления от коллизий делаем ключ огромного размера

## 2. Кластеризованный индекс

`def` **Кластеризованный индекс** - файл упорядочен по ключевому или неключевому атрибуту, по которому построен индекс, при этом несколько кортежей (кластер) соответствует одному значению индекса.

| Ключ (хеш от ФИО) | Значение (адрес кортежа в таблице) |
| :---------------: | :--------------------------------: |
|       hashValue   |               value                |

## 3. **Вторичный** индекс

`def` **Вторичный индекс** - индекс, который построен по аттрибуту, отличному от того, по которому осуществлено упорядочивание

> Первый вариант

| Ключ (табельный) | Значение (адрес кортежа в таблице) |
| :--------------: | :--------------------------------: |
|       308372     |                value               |

При этом у нас сама таблица отсортирована по ФИО.

> Проблема заключается в том, что нам может понадобиться часто балансировать структуры (деревья)

> Второй вариант

| Ключ (табельный) | Коэф сбалансированности | Значение (адрес кортежа в таблице) |
| :--------------: | :---------------------: | :--------------------------------: |
|       308372     |        balanceValue     |                value               |

## Классы индексов

1. `Плотный` - охватывает все записи
2. Разреженный - охватывает только записи, находящиеся в блоке

<br>

# 22. Использование представлений для повышений производительности и безопасности. Виды представлений. Преимущества и недостатки представлений

`def` **Представление** - это динамически сформированный результат одной или нескольких реляционных операций, выполненных над отношениями с целью получения нового отношения.

Таблица №1

| Табельный | ФИО | Группа | Паспорт |
| :-------: | :-: | :----: | :-----: |
|   308372  | Либченко М.| M32011 | не скажу |

Таблица №2

| Группы | О. Программа |
| :----: | :----------: |
| M32011 | Программирование |

Таблица №3

| О. Программа | Факальтет |
| :----------: | :-------: |
| Программирование | ФИТиП |

Появляется идея о том, чтобы закешировать часто используемые вместе данные

Закешированная таблица

| Табельный | ФИО | Группа | О. Программа | Факультет |
| :-------: | :-: | :----: | :----------: | :-------: |
|   308372  | Либченко М. | M32011 | Программирование | ФИТиП |

## Материализованные представления

