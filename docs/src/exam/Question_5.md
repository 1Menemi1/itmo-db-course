# 5. Модель сущность-связь. Классификация сущностей, атрибутов и связей. Нотация Чена для представления модели сущность-связь

> ER(A) - _сущность-отношение-атрибуты_

**Сущность** - _множество экземпляров: реальных или абстрактных однотипных предметов предметной области_

**Сильная сущность** - _может существовать независимо от остальных_

**Слабая сущность** - _может существовать только вместе с другой (сильной)_

У **сущности** могут быть **атрибуты** (свойства сущности)

**Атрибуты**:

1. Простые - номер
2. Составные - адресс, населенный пункт и тд
3. Обязательные атрибуты - однозначно индетифицировать сущность
4. Необязательные атрибуты
5. Однозначные
6. Многозначные

**Типы связей**:

1. Один к одному
2. Один ко многим
3. Многие со многим

> Нотация Чена - это правила обозначения сущностей, атрибутов связей и тд в виде диаграм.

## Нотация Чена

1. Сущности изображаются прямоугольником

    - Прямоугольник, соответствующий слабой сущности, обводится двойной рамкой

2. Атрибуты изображаются в виде овала, соединенного с соответствующим прямоугольником

    - Ключевые атрибуты выделяются подчеркиванием или служебным символом в начале имени

3. Связь обозначается ромбом

    - Ромб окружен двойной линией, если связь задана между слабой сущностью и сущностью, от которой она зависит

![Нотация чена](../Images/Chen-notation.jpg)

<br>

# 6. Логическая и физическая модели данных. Содержание уровней

## Логическая (даталогическая) модель

Определяет **способ** организации данных (концепцию), а **не конкретную реализацию**.

Набор схем отношений, обычно с указанием первичных ключей, а также связей между отношениями, представляющих собой внешние ключи. Учитывается специфика конкретной модели данных, но не учитываться специфика конкретной СУБД.

1. Иерархическая
2. Сетевая
3. Реляционная
4. ... еще какие-то Маятин не сказал

## Физическая модель

Сопоставима с внутренним уровнем (построение часто автоматизировано).

Создание схемы базы данных для конкретной СУБД: Выбор решений, связанных с физической средой хранения данных (выбор методов управления дисковой памятью, разделение БД по файлам и устройствам, методов доступа к данным), создание индексов.

1. Определяем всевозможные ограничения в названиях и т.п
2. Ограничения на типы данных (доменты атрибутов)
3. Индексы и всё такое
4. Разделение на отдельные файлы, партиции

<br>

# 7. Иерархическая и сетевая модели данных: составы моделей, преимущества и недостатки

## Иерархическая модель

> Существует только 2 типа связи: `A Kind Of` / `A Part Of`

## Компоненты иерархической модели

1. **Поле данных (аттрибут)** - минимальная неделимая, уникально адресуемая единица хранения данных

2. **Сегмент данных (запись/record/экземпляр данных)** - совокупность полей данных, имеющая уникальную идентификацию (сущность в модели ER).

3. Экземпляр сегмента — конкретные значения полей

4. Дерево — совокупность сегментов, связанных с помощью связи родитель-потомок

![Иерархическая модель](../Images/%D0%B8%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C.jpg)

**Плюсы:**

1. Более эффективное использование памяти, **относительно** простого хранения данных без какой-либо структуры

2. Более быстрое время выполнения CRUD операций, **относительно** простого хранения данных без какой-либо структуры

**Проблемы:**

1. Требуется много памяти для хранения _(производительность)_
2. Сложно контролировать целостность данных
3. Дублирование данных
4. Скорость операций записи
5. Огромные трудности при реорганизации структуры (иерархии)
6. Невозможна связь `Many-to-many`

## Сетевая модель

- Можно ссылаться много раз на один и тот же объект
- Разделяем хранение связей от хранения данных

**Агрегаты** — так называют сегменты

![Сетевая модель](../Images/%D1%81%D0%B5%D1%82%D0%B5%D0%B2%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C.jpg)

**Плюсы:**

1. Обеспечивает атрибутивную целостность

**Проблемы:**

1. Храним сущности и связи отдельно
2. Появилась проблема ссылочной целостности

<br>

# 8. Реляционная и постреляционная модели данных: составы моделей, преимущества и недостатки

## Реляционная модель

Реляционная — relationship (таблица — отношение)

![Реляционная модель](../Images/%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C.png)

## Компоненты реляционной модели

1. **Поле данных** - неделимая, уникально адресуемая единица хранения данных

2. **Отношение** - совокупность множества полей данных

3. **Связь** - хранение с помощью ключа, хранение связи = пара ключей + вес

**Один ко многим** : добавляем ID на продукт (другую сущность)

**Многие ко многим:** отдельная сущность с ID_1, ID_2, другое поле

## Нововведения

1. Связи хранятся в отдельных отношениях _(таблицах)_
2. Фактически от сетевой модели к реляционной мы переходим, реорганизовав хранение связей _(но не только)_

3. Возникают предпосылки для избежания дублирования данных
4. Позволяет гарантировать целостность данных (при грамотной организации)

5. Позволяет гарантировать избежание дублирвоания данных (при грамотной организации)

6. Позволяет гарантировать эффективное времы выполнения операций записи (при грамотной организации)

> **Сама таблица - тоже связь**

**Плюсы:**

1. Более эффективное использование памяти, **относительно** сетевоой и иерархической моделей

2. Более быстрое время выполнения CRUD операций, **относительно** сетевоой и иерархической моделей

**Проблемы:**

1. **Поле** - неделимый элемент данных, поэтому возникает проблема с определением типа данных и их хранением

## Постреляционная модель

> Фактически это реляционная модель, но без целостности данных - поле данных может само по себе являться агрегатом (снимаем требование неделимости с отдельного поля)

Поле данных - _агрегат_

**Плюсы:**

1. Представление данных становится наглядным и нет необходимости соединять таблицы.

**Проблемы:**

1. При нормализации отношенией не гарантируется получение целостных данных, так как мы выносим данные из понятия отношений

2. Целостность данных ложится на плечи разработчиков

3. При большом количестве данных все алгоритмы в основном работают за `O(e)`
