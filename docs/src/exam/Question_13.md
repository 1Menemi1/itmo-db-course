# 13. Операции реляционной алгебры: Тета-соединение, эквисоединение, естественное соединение, левое внешнее соединение, полусоединение

## Небинарные

## 1. Декартово произведение - `R x S`

`def` **Декартово произведение** - определяет новое отношение, которое является результатом конкатенаци каждого кортежа из отношения R с каждым кортежем из отношения S.

## 2. Тета-соединение - `R _f S`, где `f = R * a_i (Theta) S * b_i, (Theta) = { <, <=, =, >, >= }`

`def` **Тета-соединение** (`R _f S`) - определяет новое отношение, которое содержит кортежи из декартова произведения отношений R и S, удовлетворяющие предикату f

___

> Дополнительные операции, не реализованные в `SQL`

## 3. Экви-соединение

`def` **Экви-соединение** - это тета-соединение, где (theta) - это операция равно

## 4. Естественное соединение - `R _ S`

`def` **Естественное соединение** - это соединение по эквивалентности двух отношений, выполненное по всем общим аттрибутам, из результатов которого исключается по одному экземпляру каждого общего аттрибута.

## 5. Левое внешнее соединение - ``

`def` **Левое внешнее соединение** - это тета-соединение, при котором в результирующее отношение включаются также кортежи отношения R, не имеющие совпадающих значений в общих столбцах отношения S.

## 6. Полу-соединение

`def` **Полу-соединение** - определяет отношение, содержащее только те кортежи из R, которые входят в соединение R и S

<br>

# 14. Структура и порядок выполнения предложения Select в SQL

## Как выглядит SELECT

```sql
SELECT [DISTINCT | ALL] { * | [ColumsExpression [AS NewName], ... ] }
FROM TableName [AS NewName]
    [ { INNER | LEFTOUTER | FULL } JOIN ] TasbeName2 [AS NewName]
    ON condition ]
[ WHERE condition ]
[ GROUP BY ColumnList ]
[ HAVING condition ]
[ ORDER BY ColumnList [ ASC | DESC ]]
```

## Последовательность выполнения SELECT

1. `FROM`
2. `JOIN ... ON`
3. `WHERE`
4. `GROUP BY`
5. `HAVING`
6. `SELECT`
7. `DISTINCT`
8. `ORDER BY`

<br>

# 15. Алгоритмы реализации соединений отношений в SQL

Для того, чтобы обеспечить целостность, мы будем заниматься денормализацией _(создавать множество связанных таблиц)_.

Это приводит к снижению **производительности**.

> Соединение таблиц - это дорого!

## 1. Неэффективно (декартово произведение)

> Вложенный цикл

```csharp
for (int i = 0; i < R.Count; ++i)
{
    for (int j = 0; j < S.Count; ++j)
    {
        if (R[i].atr != S[j].atr) continue;
        Console.WriteLine(r + s);
    }
}
```

```py
for r in R
    for s in S
        if (r.atr == s.atr)
            print(r + s)
```

## 2. Эффективно

> Предварительная сортировка

```py
R.sort(atr)
S.sort(atr)

while not EndOF(S) ans not EndOF(R)
    if (r.atr < s.atr)
        next(R)
    if (r.atr = s.atr)
        print(r + s)
        next(R)
    if (r.atr > s.atr)
        next(S)
```

<br>

# 16. Нормализация реляционной модели: избыточность, аномалии, суть метода нормальных форм. Виды зависимостей между атрибутами

`def` **Нормализация** - преобразование отношения к виду, отвечающему нормальной форме.

> **Нормальная форма** - некоторая характеристика отношения.

У нормальных форм есь иерархия: каждая следующая является предыдущей.

## Избыточность

**Студент**

|     Фио     | Группа | Образовательная программа |
| :---------: |:------:| :------------------------:|
| Либченко М. | M32011 |      Программирование     |

> Образовательная программа хранится либо у одного студента, либо у всех сразу. В обоих случаях это приводит к своим издержкам.

## Аномалия

## 1. Модификации

`def` **Аномалия модификации** - изменение значения одной записи привлечёт за собой просмотр всей таблицы и изменения некоторых других записей.

## 2. Удаления

`def` **Аномалия удаления** - при удалении записи может пропасть и другая информация.

## 3. Добавления

`def` **Аномалия добавления** - информацию в таблицу нельзя поместить, пока она неполная или требуется дополнительный просмотр табиц.

> Аномалии потенциально приводят нас к нарушению целостности данных.

## Решение проблемы аномалии

**Расширенная таблица студентов**

|  Фио `(PK)` | Группа `(PK)` | Образовательная программа |  Факультет  | Форма обучения |
| :---------: |:-------------:| :-----------------------: |:-----------:| :------------: |
| Либченко М. |     M32011    |      Программирование     |     ФИТиП   |      Очная     |

## Виды зависимостей между атрибутами

## Функциональная зависимость между аттрибутами

`def` **Функциональная зависимость между аттрибутами** `(X -> Y)` - в отношении R атрибут y функцинально зависит от атрибута x тогда и только тогда, когда каждому значению x соответствует в точности одно значение y.

> Факультет функционально зависит от образовательной программы.

## Частичная функциональная зависимость

`def` **Частичная функциональная зависимость** `(ФИО + Группа) -> Образовательная программа` - зависимость неключевого атрибута от часть составного ключа.

## Полная функциональная зависимость

`def` **Полная функциональная зависимость** `(ФИО + Группа) -> Форма обучения` - неключевой атрибут зависит от всего составного ключа.

## Транзитивная функциональная зависимость

`def` **Транзитивная функциональная зависимость** `(X -> Z, Y: X -> Y && Y -> Z)` - существует такое множество атрибутов Y, что выполняется требование о существовании зависимостей `X -> Y && Y -> Z)`

<br>

# 17. Первая и вторая нормальные формы. Примеры

## Первая нормальная форма

`def` Отношение находится в **первой нормальной форме**, если все его атрибуты явзяются простыми.

> ФИО мешает нашей таблице соответствовать первой нормальной форме. Для того, чтобы таблица студента находилась в ПНФ, необходимо разделить столбец ФИО на 3 столбца: Ф, И, О

## Вторая нормальная форма

`def` Отношение находится **во второй нормальной форме**, если оно находится в первой нормальной форме, и каждый неключевой атрибут **функционально полно** зависит от первичного ключа.

|  Ф  |  И  |  О  |  Группа  | Форма обучения |
| :-: | :-: | :-: | :------: | :------------: |
|  Л. |  М. |  В. |  M32011  |      Очная     |

| Группа | Образовательная программа |  Факультет  |
| :----: | :-----------------------: | :---------: |
| M32011 |      Программирование     |    ФИТиП    |

<br>

# 18. Третья нормальная форма. Примеры

## Третья нормальная форма

`def` Отношение находится **в третьей нормальной форме**, если оно находится во второй нормальной форме, и все неключевые атрибуты взаимно независимы и полностью зависят от первичного ключа.

`def` Отношение находится **в третьей нормальной форме**, если оно находится во второй нормальной форме, и ни один ключевой атрибут не находится в транзитивной функциональной зависимости от потенциального ключа.

|  Ф  |  И  |  О  |  Группа  | Форма обучения |
| :-: | :-: | :-: | :------: | :------------: |
|  К. |  И. |  Э. |  M32011  |      Очная     |

| Группа | Образовательная программа |
| :----: | :-----------------------: |
| M32011 |      Программирование     |

| Образовательная программа | Факультет |
| :-----------------------: | :-------: |
|      Программирование     |   ФИТиП   |

<br>

# 19. Нормальная форма Бойса-Кодда. Примеры

## Нормальная форма Бойса-Кодда

**Проекты**

|  Номер студента  |     ФИО    |  Номер проекта  |  Роль  |
| :--------------: | :--------: | :-------------: | :----: |
|       307484     | Кудашев И. |         1       | Бекенд |

> Данное отношение не соответствует НФ Бойса-Кодда

`def` Отношение находится **в нормальной форме Бойса-Кодда**, если детерминанты _(зависимые части)_ всех зависимостей являются потенциальными ключами.

## Приведение к нормальной форме Бойса-Кодда

| Студент | Номер студента |    ФИО    |
| :-----: | :------------: | :-------: |
| Кудашев |      307484    |  К. И. Э. |

|  Номер студента  |  Номер проекта  |  Роль  |
| :--------------: | :-------------: | :----: |
|       307484     |         1       | Бекенд |

<br>

# 20. Четвертая нормальная форма. Примеры

## Четвёртая нормальная форма

`def` Отношение находится **в четвёртой нормальной форме**, если оно находится в нормальной форме Бойса-Кодда, и не содержит многозначных зависимостей.

|  Дисциплина |    Лектор    |    Практик   |
| :---------: | :----------: | :----------: |
| Базы данных | Маятин А. В. | Маятин А. В. |

> Не соответствует четвёртой нормальной форме, но соответствует всем предыдущим

## Приведение к четвёртой нормальной форме**

**Лекторы**

|  Дисциплина |     Лектор   |
| :---------: | :----------: |
| Базы данных | Маятин А. В. |

**Практики**

|  Дисциплина |    Практик    |
| :---------: | :-----------: |
| Базы данных |  Маятин А. В. |

> Вопрос приведения к четвёртой нормальной форме - вопрос **интерпритации** данных.

<br>

# 21. Использование индексов для повышения производительности. Виды индексов

> Индекс - это механизм, который направлен на оптимизацию поиска.

Таблица №1

| Табельный |     ФИО     | Группа |
| :-------: | :---------: | :----: |
|  308372   | Либченко М. | M32011 |

Таблица №2

| Группа |   О. Программа   |
| :----: | :--------------: |
| M32011 | Программирование |

`def` **Индекс** - это метод, который позволяет получить структуру данных, предназначенную для оптимизации поиска.

Как выглядит индекс:

| Ключ | Значение (адрес кортежа в таблице) |
| :--: | :--------------------------------: |
| key  |                value               |

## Варианты индексов

## 1. Первичный индекс

`def` **Первичный индекс** - файл упорядочен по первичному ключу, и по нему же построен индекс, так что гарантируется уникальность каждой записи (кортежа)

| Ключ (Табельный) | Значение (адрес кортежа в таблице) |
| :--------------: | :--------------------------------: |
|      308372      |               value                |

Этот индкс можно переформатировать в какую-нибудь структуру данных, например, **красно-чёрное дерево**

- **Хеш** индекс

| Ключ (хеш табельного) | Значение (адрес кортежа в таблице) |
| :-------------------: | :--------------------------------: |
|       hashValue       |                value               |

> Для избавления от коллизий делаем ключ огромного размера

## 2. Кластеризованный индекс

`def` **Кластеризованный индекс** - файл упорядочен по ключевому или неключевому атрибуту, по которому построен индекс, при этом несколько кортежей (кластер) соответствует одному значению индекса.

| Ключ (хеш от ФИО) | Значение (адрес кортежа в таблице) |
| :---------------: | :--------------------------------: |
|       hashValue   |               value                |

## 3. **Вторичный** индекс

`def` **Вторичный индекс** - индекс, который построен по аттрибуту, отличному от того, по которому осуществлено упорядочивание

> Первый вариант

| Ключ (табельный) | Значение (адрес кортежа в таблице) |
| :--------------: | :--------------------------------: |
|       308372     |                value               |

При этом у нас сама таблица отсортирована по ФИО.

> Проблема заключается в том, что нам может понадобиться часто балансировать структуры (деревья)

> Второй вариант

| Ключ (табельный) | Коэф сбалансированности | Значение (адрес кортежа в таблице) |
| :--------------: | :---------------------: | :--------------------------------: |
|       308372     |        balanceValue     |                value               |

## Классы индексов

1. `Плотный` - охватывает все записи
2. Разреженный - охватывает только записи, находящиеся в блоке

<br>

# 22. Использование представлений для повышений производительности и безопасности. Виды представлений. Преимущества и недостатки представлений

`def` **Представление** - это динамически сформированный результат одной или нескольких реляционных операций, выполненных над отношениями с целью получения нового отношения.

Таблица №1

| Табельный | ФИО | Группа | Паспорт |
| :-------: | :-: | :----: | :-----: |
|   308372  | Либченко М.| M32011 | не скажу |

Таблица №2

| Группы | О. Программа |
| :----: | :----------: |
| M32011 | Программирование |

Таблица №3

| О. Программа | Факальтет |
| :----------: | :-------: |
| Программирование | ФИТиП |

Появляется идея о том, чтобы закешировать часто используемые вместе данные

Закешированная таблица

| Табельный | ФИО | Группа | О. Программа | Факультет |
| :-------: | :-: | :----: | :----------: | :-------: |
|   308372  | Либченко М. | M32011 | Программирование | ФИТиП |

## Материализованные представления

`def` **Материализованное представление** - храним дубликаты данных, полученные в результате выполнения некоторого запроса, **непосредственно** в памяти

## Представления замены

`def` **Представление замены** - хранится только подзапрос, который выполняется когда нужно выполнить родительский запрос, и просто отдаёт в этот родительский запрос нужные данные.

> Выигрываем по безопасности

Тут мы делаем представление, ограничивая выдаваемые данные, засчёт чего обеспечиваем безопасность

## Типы представлений

1. Обновляемые
2. Необновляемые

## Преимущества представлений

1. Независимость от данных
2. Повышение защищённости данных
3. Снижение сложности запросов

## Недостатки представлений

1. Ограниченные возможности представлений
2. Структурные ограничения
3. Снижение производительности

<br>

# 23. Транзакции. Понятие транзакции. Свойства транзакции

`def` **Транзакция** - последовательность действий с базой данных, в которой либо все действия выполняются успешно, либо не выполняется ни одно из них. 

> По факту это преобразование бд из одного логически-согласованного состояния в другое логически-согласованного состояния, подразумевая, что в промежутке бд могла находиться в логически-несогласованном состоянии

## Свойства транзакций

Выполнение всех четырёх свойств одновременно гарантирует надёжность операций

1. Атомарность

    Транзакция неделима, т.е. либо выполняются все её действия, либо ни одного

2. Согласованность

    Транзакция переводит одно согласованное состояние бд в другое без соблюдения обязательной согласованности в промежуточных точках

3. Изоляция

    Если запущено несколько конкурирующих транзакций, то любое обновление состояния бд, выполненное одной транзакцией, скрыто от других до её завершения

4. Долговечность

    Когда транзакция завершена, её результаты обновления сохраняются, даже если в следующий момент произовдёт сбой

<br>

# 24. Проблемы конкурирующих транзакций и методы их решения. Уровни изоляции транзакций

## Проблемы конкурирующих транзакций

1. Проблема потерянного обновления

    Несколько транзакций меняют один и тот же кортеж, в результате сохраится только резльтат внесения изменений последенй транзакции.

    > Кладём и списываем деньги со всёта

2. Проблема грязного чтения

    При чтении одной транзакции кортежа, который уже изменён, но ещё не сохранён другой уже завершившейся транзакцией, которая будет потом отменена.

    > Кладём и списываем деньги со счёта, после этого пытаемся отменить пополнение

3. Проблема неповторяемого чтения

    При повторном чтении данных, уже считанных ранее, транзакция обнаруживает модификацию, вызванную другой завершённой транзакции.

4. Проблема фантомного чтения

    При повторной выборке, выполняющий некоторый запрос, могут попасть новые кортежи

    > Сначала считываем данные, потом добавляем новую запись и на основе считанных данных получаем неверный результат (например, среднее значение в параллельных подзапросах)

## Блокировки

> Все транзакции строятся на основе блокировок - блокировки кортежей, аттрибутов, таблиц или всей базы данных

## Классификация блокировок

1. Явные (накладывающиеся пользователем)

2. Неявные (накладывающиеся самой СУБД)

3. Монопольные - блокируются все виды доступа к объектам

4. Коллективные - блокируются доступ к чтению? к объектам

Дедлоки

> Если одна из транзакций пытается наложить блокировку, пересекающиеся с какой-то другой блокировкой - появление **дедлоков**

## Уровни изоляции (для решения конкурирующих транзакций)

1. Незавершённое чтение

    Требует, чтобы изменять данные могла только одна транзакция. Поможет справиться с **проблемой потерянного обновления**.

2. Завершённое чтение

    Если транзакция начала изменение данных, то никакая другая транзакция не сможет их прочитать до завершения первой. Поможет справитсья с **проблемой грязного чтения**.

3. Воспроизводимое чтение

    Если транзакция считывает данные, то никакая другая транзакция не сможет их изменить до завершения первой. _Видимо_, поможет справиться с **проблемой неповторяемого чтения**

4. Сериализуемость

    Если транзакция обращается к данным, то никакая другая транзакция не сможет добавить новые или изменить существующие кортежи в этом объекте данных. _Видимо_, поможет справиться с **проблемой фантомного чтения**

## Долговечность

Обеспечивается журналируемостью транзакций

<br>

# 25. Иерархия уровней безопасности по оранжевой книге. Понятия идентификации и аутентификации

`def` **Безопасная компьютерная система** - посредством специальных механизмов защиты контроллируется доступ к информации, таким образом, что только имеющие соотсетствующие полномочия лица или процессы, выполняющиеся от их имени, могут получить доступ на чтение, изменение создание или удаление информации.

> Существует 4 основных уровня, но некоторые имеют свои подуровни

## Уровень D

> Когда истема не попадает ни в один из описанных классов

## Уровень C

> Самый слабый из классов безопасности

1. Подсистема идентификации и аутентификации

    - Идентификация - **присвоение** некоторых идентификаторов субъекту

        - То что субъект знает (кодовое слово)
        - То, что субъекту принадлежит (карта, токен)
        - То, что является его неотъемлемой характеристикой (биометрия)

    - Аутентификация - **сопоставление** предъявляемого идентификатора и того, который хранится в системе

    - Авторизация - **назначение** тех или иных прав доступа субъекту, прошедшему аутентификацию

2. Подсистема учёта событий, связанных с безопасностью

3. Изберательный (дискреционный) контроль доступа - в том или ином виде существует матрица вида: субъекты <-> объекты
  
    ![Дискреционный контроль](../Images/%D0%B4%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C.jpg)

## Уровень C1

1. Разделение пользователей и данных
2. Выделение контура обеспечения безопасности

    `def` **Доверенная вычислительная база** - совокупность защитных механизмов, включающих аппаратное и программное обеспечение, отвечающих за приведение в жизнь политики безопасности.

    > По факту это анличие отдельного прилоэения/процесса, которое будет заниматься исколючиткльно решением задач, связанных с безопасностью

3. Сдерства проверки корректности функционирования аппаратных и программных компонентов вычислительной базы (тест, что машина и программа аутентификации вообще работают)
